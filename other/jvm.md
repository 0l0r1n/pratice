# JVM

JVM is the runtime to run java applications. The JVM is what actually calls the main method inside an app.

When we compile a .java file, .class files(contains byte-code) with the same class names present in .java file are generated by the Java compiler. This .class file goes into various steps when we run it. These steps together describe the whole JVM.

## Class loader Subsystem

Mainly responsible for three activities:

- Loading
- Linking
- Initialization

### Loading

- Reads the .class file, generating binary dava and save it in method area. For each .class file, JVM stores the following information in the method area:
  - Fully qualifield name of the loaded class and the parent class
  - Whether .class is related to a class, interface or enum
  - Modifier, variables and method info
- After loading the .class file, JVM creates an object of type class to represent this file in the heap memory. Please note that this object is of type Class predefined in java.lang. For every loaded .class file, only one object of Class is created.
- Linking: performs verification, preparation and optionally resolution
  - Verification: ensures correctness of .class file
  - Preparation: JVM allocates memory for class variables and initializing the memory to default values
  - Resolution: process of replacing symbolic references from the type with direct references.

### Initialization

In this phase, all static variables are assigned with their value defined in the code as well as static blocks. There are three class loaders:

- Bootstrap class loader: loads trusted classes, java API classes. Present in JAVA_HOME/jre/lib
- Extension class loader: classes present in JAVA_HOME/jre/ext
- System/Application class loader: loads classes from application class path

Classpath is a parameter in the Java Virtual Machine or the Java compiler that specifies the location of user-defined classes and packages. The parameter may be set either on the command-line, or through an environment variable.

### JVM Memory