# JVM

JVM is the runtime to run java applications. The JVM is what actually calls the main method inside an app.

When we compile a .java file, .class files(contains byte-code) with the same class names present in .java file are generated by the Java compiler. This .class file goes into various steps when we run it. These steps together describe the whole JVM.

## Class loader Subsystem

Mainly responsible for three activities:

- Loading
- Linking
- Initialization

### Loading

- Reads the .class file, generating binary dava and save it in method area. For each .class file, JVM stores the following information in the method area:
  - Fully qualifield name of the loaded class and the parent class
  - Whether .class is related to a class, interface or enum
  - Modifier, variables and method info
- After loading the .class file, JVM creates an object of type class to represent this file in the heap memory. Please note that this object is of type Class predefined in java.lang. For every loaded .class file, only one object of Class is created.
- Linking: performs verification, preparation and optionally resolution
  - Verification: ensures correctness of .class file
  - Preparation: JVM allocates memory for class variables and initializing the memory to default values
  - Resolution: process of replacing symbolic references from the type with direct references.

### Initialization

In this phase, all static variables are assigned with their value defined in the code as well as static blocks. There are three class loaders:

- Bootstrap class loader: loads trusted classes, java API classes. Present in JAVA_HOME/jre/lib
- Extension class loader: classes present in JAVA_HOME/jre/ext
- System/Application class loader: loads classes from application class path

Classpath is a parameter in the Java Virtual Machine or the Java compiler that specifies the location of user-defined classes and packages. The parameter may be set either on the command-line, or through an environment variable.

### JVM Memory

Method area: In method area, all class level information like class name, immediate parent class name, methods and variables information etc. are stored, including static variables. There is only one method area per JVM, and it is a shared resource.

Heap area: all object information is stored in heap area. One heap area by JVM.

Stack area: for every thread, JVM creates one run time stack which is stored here.

PC Register: store address of current execution instruction of a thread.

Native method stacks: For every thread, separate native stack is created. It stores native method information.

### Execution Engine

Executes the .class bytecode. It reads the bytecode line by line, use data and information present in various memory area and execute instructions. It can be classified in three parts:

- Interpreter: It interprets the bytecode line by line and then executes. The disadvantage here is that when one method is called multiple times, every time interpretation is required.
- JIT Compiler: It is used to increase efficiency of interpreter.It compiles the entire bytecode and changes it to native code so whenever interpreter see repeated method calls,JIT provide direct native code for that part so re-interpretation is not required,thus efficiency is improved.
- Gargabe Collector: It destroy un-referenced objects.